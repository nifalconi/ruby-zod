# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dry-schema/all/dry-schema.rbi
#
# dry-schema-1.13.4

module Dry
end
module Dry::Schema
  def self.Form(**options, &block); end
  def self.JSON(**options, &block); end
  def self.Params(**options, &block); end
  def self.config; end
  def self.define(**options, &block); end
  def self.loader; end
  extend Dry::Core::Extensions
  include Dry::Core::Constants
end
class Dry::Schema::Processor
  def [](input); end
  def ^(_other); end
  def ast(*); end
  def call(input); end
  def config; end
  def filter_rules?; end
  def filter_schema; end
  def inspect; end
  def key_map; end
  def merge(other); end
  def message_compiler; end
  def rule_applier; end
  def rules; end
  def self.define(&block); end
  def self.definition; end
  def self.new(options = nil, &block); end
  def strict_type_schema; end
  def to_ast(*); end
  def to_proc; end
  def to_rule; end
  def type_schema; end
  def types; end
  def xor(_other); end
  extend Anonymous_Dry_Configurable_Extension_35
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  extend Dry::Initializer
  include Anonymous_Module_34
  include Dry::Initializer::Mixin::Root
  include Dry::Logic::Operators
end
module Anonymous_Module_34
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  def schema_dsl; end
  def steps; end
  extend Dry::Initializer::Mixin::Local
end
module Anonymous_Dry_Configurable_Extension_35
end
module Anonymous_Module_36
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Params < Dry::Schema::Processor
  include Anonymous_Module_36
end
class Dry::Schema::InvalidSchemaError < StandardError
end
class Dry::Schema::MissingMessageError < StandardError
  def initialize(path, paths = nil); end
end
module Dry::Schema::Types
  extend Anonymous_Dry_Core_Deprecations_Tagged_37
  extend Anonymous_Module_38
  extend Dry::Core::Deprecations::Interface
  extend Dry::Types::BuilderMethods
  include Anonymous_Dry_Types_Module_39
end
module Dry::Schema::Types::Definition
end
module InvalidName___Dry__Types__Module_0x00___Strict_40
end
module InvalidName___Dry__Types__Module_0x00___Coercible_41
end
module InvalidName___Dry__Types__Module_0x00___Optional_42
end
module InvalidName___Dry__Types__Module_0x00___Optional__Strict_43
end
module InvalidName___Dry__Types__Module_0x00___Optional__Coercible_44
end
module InvalidName___Dry__Types__Module_0x00___Optional__Params_45
end
module InvalidName___Dry__Types__Module_0x00___Params_46
end
module InvalidName___Dry__Types__Module_0x00___JSON_47
end
module Anonymous_Dry_Types_Module_39
  def self.included(base); end
  extend Dry::Types::BuilderMethods
end
module Anonymous_Dry_Core_Deprecations_Tagged_37
end
module Anonymous_Module_38
  def const_missing(missing); end
end
class Dry::Schema::DSL
  def [](name); end
  def after(key, &block); end
  def array; end
  def before(key, &block); end
  def call; end
  def compiler; end
  def configure(&block); end
  def custom_type?(name); end
  def default_config; end
  def filter_rules?; end
  def filter_schema; end
  def filter_schema_dsl; end
  def key(name, macro:, &block); end
  def key_coercer; end
  def key_map(types = nil); end
  def key_map_type; end
  def key_spec(name, type); end
  def key_validator; end
  def merge(other); end
  def merge_types(op_class, lhs, rhs); end
  def new(klass: nil, **options, &block); end
  def optional(name, &block); end
  def parent; end
  def parent_filter_schemas; end
  def parent_key_map; end
  def parent_rules; end
  def predicates; end
  def required(name, &block); end
  def resolve_type(spec); end
  def rule_applier; end
  def rules; end
  def self.new(**options, &block); end
  def set_type(name, spec); end
  def strict_type_schema; end
  def to_rule; end
  def type_registry; end
  def type_schema; end
  def types; end
  def types_merger; end
  def value_coercer; end
  extend Dry::Initializer
  include Anonymous_Module_48
  include Dry::Initializer::Mixin::Root
end
module Anonymous_Module_48
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  def config; end
  def macros; end
  def parents; end
  def path; end
  def processor_type; end
  def steps; end
  def types; end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::PredicateRegistry < Dry::Types::PredicateRegistry
  def arg_list(name, *values); end
end
class Dry::Schema::Config
  def inspect; end
  def method_missing(meth, *args, &block); end
  def respond_to_missing?(meth, include_private = nil); end
  extend Dry::Configurable::ClassMethods
  include Anonymous_Dry_Configurable_Extension_49
  include Anonymous_Dry_Core_Equalizer_50
  include Dry::Configurable
  include Dry::Configurable::InstanceMethods
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Configurable_Extension_49
end
module Anonymous_Dry_Core_Equalizer_50
  def cmp?(comparator, other); end
  def hash; end
end
class Dry::Schema::ProcessorSteps
  def [](name); end
  def []=(name, value); end
  def after(name, &block); end
  def before(name, &block); end
  def call(result); end
  def import_callbacks(path, other); end
  def key_map; end
  def merge(other); end
  def merge_callbacks(left, right); end
  def rule_applier; end
  def type_schema; end
  extend Dry::Initializer
  include Anonymous_Module_51
  include Dry::Initializer::Mixin::Root
end
module Anonymous_Module_51
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  def after_steps; end
  def before_steps; end
  def steps; end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Path
  def &(other); end
  def <=>(other); end
  def each(&block); end
  def include?(other); end
  def initialize(keys); end
  def keys; end
  def last; end
  def root(*arg0); end
  def same_root?(other); end
  def self.[](spec); end
  def self.call(spec); end
  def self.keys_from_hash(hash); end
  def to_h(value = nil); end
  include Anonymous_Dry_Core_Equalizer_52
  include Comparable
  include Dry::Core::Equalizer::Methods
  include Enumerable
end
module Anonymous_Dry_Core_Equalizer_52
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Dry::Schema::Macros
end
class Dry::Schema::Macros::Core
  def ast(*); end
  def new(**options); end
  def operation; end
  def path; end
  def to_ast(*); end
  def to_rule; end
  extend Dry::Initializer
  include Anonymous_Module_53
  include Dry::Initializer::Mixin::Root
end
module Anonymous_Module_53
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  def compiler; end
  def name; end
  def schema_dsl; end
  def trace; end
  extend Dry::Initializer::Mixin::Local
end
module Anonymous_Module_54
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  def chain; end
  def predicate_inferrer; end
  def primitive_inferrer; end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Macros::DSL < Dry::Schema::Macros::Core
  def append_macro(macro_type); end
  def array(*, **, &); end
  def custom_type?; end
  def each(*, **, &); end
  def extract_type_spec(args, nullable: nil, set_type: nil); end
  def filled(*args, **opts, &block); end
  def hash(*, **, &); end
  def maybe(*args, **opts, &block); end
  def resolve_type(type_spec, nullable); end
  def schema(*, **, &); end
  def schema_or_predicate?(arg); end
  def type(spec); end
  def value(*args, **opts, &block); end
  include Anonymous_Module_54
  include Dry::Logic::Operators
end
module Anonymous_Module_55
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  def filter_schema_dsl; end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Macros::Key < Dry::Schema::Macros::DSL
  def filter(*, **, &); end
  def to_ast; end
  def to_rule; end
  include Anonymous_Module_55
end
module Anonymous_Module_56
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Macros::Required < Dry::Schema::Macros::Key
  def operation; end
  include Anonymous_Module_56
end
class Dry::Schema::Compiler < Dry::Logic::RuleCompiler
  def self.new(predicates = nil); end
  def support?(predicate); end
  def visit_and(node); end
  def visit_namespace(node, _opts = nil); end
end
class Dry::Schema::Trace < BasicObject
  def <<(op); end
  def append(op); end
  def captures; end
  def class; end
  def compiler; end
  def evaluate(*args, **opts); end
  def evaluate_predicates(predicates); end
  def initialize(compiler = nil); end
  def method_missing(meth, *args, &block); end
  def reduced_rule; end
  def respond_to_missing?(meth, include_private = nil); end
  def to_ast; end
  def to_rule(name = nil); end
  include Anonymous_Dry_Core_Equalizer_57
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_57
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::PredicateInferrer < Dry::Types::PredicateInferrer
  def initialize(registry = nil); end
end
class Dry::Schema::PredicateInferrer::Compiler < Dry::Types::PredicateInferrer::Compiler
end
class Dry::Schema::PrimitiveInferrer < Dry::Types::PrimitiveInferrer
  def initialize; end
end
class Dry::Schema::PrimitiveInferrer::Compiler < Dry::Types::PrimitiveInferrer::Compiler
end
class Dry::Schema::TypeRegistry
  def [](name); end
  def initialize(types, namespace = nil); end
  def namespace; end
  def namespaced(ns); end
  def self.new(types = nil, namespace = nil); end
  def types; end
end
module Anonymous_Module_58
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Macros::Value < Dry::Schema::Macros::DSL
  def array_type?(type); end
  def build_array_type(array_type, member); end
  def call(*args, **opts, &block); end
  def hash_type?(type); end
  def import_steps(schema); end
  def maybe_type?(type); end
  def method_missing(meth, *args, &block); end
  def respond_to_missing?(meth, include_private = nil); end
  include Anonymous_Module_58
end
module Anonymous_Module_59
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(*, **__dry_initializer_options__); end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::Macros::Filled < Dry::Schema::Macros::Value
  def call(*predicates, **opts, &block); end
  def ensure_valid_predicates(predicates); end
  def expected_primitives; end
  def filter_empty_string?; end
  def processor_config; end
  def schema_type; end
  include Anonymous_Module_59
end
class Dry::Schema::Predicate
  def !; end
  def args; end
  def arity; end
  def ast(*); end
  def block; end
  def compiler; end
  def ensure_valid; end
  def initialize(compiler, name, args, block); end
  def name; end
  def to_ast(*); end
  def to_rule; end
  include Anonymous_Dry_Core_Equalizer_60
  include Dry::Core::Equalizer::Methods
  include Dry::Logic::Operators
end
class Dry::Schema::Predicate::Negation
  def ast(*, **, &); end
  def initialize(predicate); end
  def predicate; end
  def to_ast(*, **, &); end
  include Dry::Logic::Operators
end
module Anonymous_Dry_Core_Equalizer_60
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::KeyCoercer
  def [](result); end
  def call(result); end
  def coercer; end
  def initialize(key_map, &coercer); end
  def key_map; end
  def self.new(*args); end
  def self.symbolized(*args); end
  extend Dry::Core::Cache
  include Anonymous_Dry_Core_Equalizer_61
  include Dry::Core::Cache::Methods
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_61
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::KeyMap
  def +(other); end
  def coercible(&coercer); end
  def dump; end
  def each(&block); end
  def initialize(keys); end
  def inspect; end
  def keys; end
  def self.[](*keys); end
  def self.new(*args); end
  def stringified; end
  def to_dot_notation; end
  def write(source, target = nil); end
  extend Dry::Core::Cache
  include Anonymous_Dry_Core_Equalizer_62
  include Dry::Core::Cache::Methods
  include Dry::Core::Equalizer::Methods
  include Enumerable
end
module Anonymous_Dry_Core_Equalizer_62
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::Key
  def coerced_name; end
  def coercer; end
  def coercible(&coercer); end
  def dump; end
  def id; end
  def initialize(id, name: nil, coercer: nil); end
  def name; end
  def new(**new_opts); end
  def read(source); end
  def self.[](name, **opts); end
  def self.new(*args, **kwargs); end
  def stringified; end
  def to_dot_notation; end
  def write(source, target); end
  extend Dry::Core::Cache
  include Anonymous_Dry_Core_Equalizer_63
  include Dry::Core::Cache::Methods
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_63
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::Key::Hash < Dry::Schema::Key
  def coercible(&coercer); end
  def dump; end
  def initialize(id, members:, **opts); end
  def members; end
  def read(source); end
  def stringified; end
  def to_dot_notation; end
  def write(source, target); end
  include Anonymous_Dry_Core_Equalizer_64
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_64
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::Key::Array < Dry::Schema::Key
  def coercible(&coercer); end
  def dump; end
  def initialize(id, member:, **opts); end
  def member; end
  def stringified; end
  def to_dot_notation; end
  def write(source, target); end
  include Anonymous_Dry_Core_Equalizer_65
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_65
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::Step
  def call(result); end
  def executor; end
  def initialize(type:, name:, executor:, path: nil); end
  def name; end
  def path; end
  def scoped(parent_path); end
  def type; end
  def validate_name(name); end
end
class Dry::Schema::ValueCoercer
  def call(input); end
  extend Dry::Initializer
  include Anonymous_Dry_Core_Equalizer_67
  include Anonymous_Module_66
  include Dry::Core::Equalizer::Methods
  include Dry::Initializer::Mixin::Root
end
module Anonymous_Module_66
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(type_schema, *); end
  def type_schema; end
  extend Dry::Initializer::Mixin::Local
end
module Anonymous_Dry_Core_Equalizer_67
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::RuleApplier
  def call(input); end
  def to_ast; end
  extend Dry::Initializer
  include Anonymous_Module_68
  include Dry::Initializer::Mixin::Root
end
module Anonymous_Module_68
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(rules, *, **__dry_initializer_options__); end
  def config; end
  def message_compiler; end
  def rules; end
  extend Dry::Initializer::Mixin::Local
end
class Dry::Schema::MessageCompiler
  def append_mapped_size_tokens(tokens); end
  def call(ast); end
  def default_lookup_options; end
  def initialize(messages, **options); end
  def lookup_options(arg_vals:, input:); end
  def message_text(template, tokens, options); end
  def message_tokens(args); end
  def message_type(*); end
  def options; end
  def or_translator; end
  def visit(node, opts = nil); end
  def visit_and(node, opts); end
  def visit_failure(node, opts); end
  def visit_hint(*); end
  def visit_implication(node, *args); end
  def visit_key(node, opts); end
  def visit_namespace(node, opts); end
  def visit_not(node, opts); end
  def visit_or(node, opts); end
  def visit_predicate(node, opts); end
  def visit_set(node, opts); end
  def visit_unexpected_key(node, opts); end
  def visit_xor(node, opts); end
  def with(new_options); end
  extend Dry::Initializer
  include Anonymous_Module_69
  include Dry::Initializer::Mixin::Root
end
class Dry::Schema::MessageCompiler::VisitorOpts < Hash
  def call(other); end
  def current_messages; end
  def dup(current_messages = nil); end
  def failures; end
  def hints; end
  def key_failure?(path); end
  def path; end
  def self.new; end
end
class Dry::Schema::MessageSet
  def [](key); end
  def combine_message_hashes(hashes); end
  def combine_message_values(values); end
  def each(&block); end
  def empty?; end
  def fetch(key); end
  def freeze; end
  def initialize(messages, options = nil); end
  def messages; end
  def messages_map(messages = nil); end
  def options; end
  def partition_message_values(values); end
  def self.[](messages, options = nil); end
  def to_h; end
  def to_hash; end
  include Anonymous_Dry_Core_Equalizer_70
  include Dry::Core::Equalizer::Methods
  include Enumerable
end
module Anonymous_Dry_Core_Equalizer_70
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Module_69
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(messages, *, **__dry_initializer_options__); end
  def full; end
  def locale; end
  def messages; end
  def predicate_resolvers; end
  extend Dry::Initializer::Mixin::Local
end
module Dry::Schema::Messages
  def self.setup(config); end
  def setup(config); end
end
class Dry::Schema::Messages::Abstract
  def [](predicate, options); end
  def call(predicate, options); end
  def custom_top_namespace?(path); end
  def default_locale; end
  def filled_lookup_paths(tokens); end
  def interpolatable_data(_key, _options, **_data); end
  def interpolate(_key, _options, **_data); end
  def key?(_key, _options = nil); end
  def looked_up_paths(predicate, options); end
  def lookup_paths(predicate, options); end
  def lookup_tokens(predicate, options); end
  def namespaced(namespace); end
  def root; end
  def rule(name, options = nil); end
  def rule_lookup_paths(tokens); end
  def self.build(options = nil); end
  def self.setting_names; end
  def translate(key, locale: nil); end
  extend Dry::Configurable::ClassMethods
  include Anonymous_Dry_Configurable_Extension_71
  include Anonymous_Dry_Core_Equalizer_72
  include Dry::Configurable
  include Dry::Configurable::InstanceMethods
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Configurable_Extension_71
end
module Anonymous_Dry_Core_Equalizer_72
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::Messages::YAML < Dry::Schema::Messages::Abstract
  def cache; end
  def data; end
  def evaluated_key(key, options); end
  def evaluation_context(key, options); end
  def get(key, options = nil); end
  def initialize(data: nil, config: nil); end
  def interpolatable_data(key, options, **data); end
  def interpolate(key, options, **data); end
  def key?(key, options = nil); end
  def load_translations(path); end
  def looked_up_paths(predicate, options); end
  def merge(overrides); end
  def prepare; end
  def self.build(options = nil); end
  def self.cache; end
  def self.flat_hash(hash, path = nil, keys = nil); end
  def self.source_cache; end
  def t; end
  include Anonymous_Dry_Core_Equalizer_73
  include Dry::Core::Equalizer::Methods
end
module Anonymous_Dry_Core_Equalizer_73
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Schema::Result
  def [](name); end
  def add_error(node); end
  def at(at_path, &block); end
  def concat(other); end
  def deconstruct_keys(_); end
  def error?(spec); end
  def errors(options = nil); end
  def failure?; end
  def inspect; end
  def key?(name); end
  def message_set(options = nil); end
  def new(output, **opts, &block); end
  def output; end
  def path; end
  def replace(value); end
  def self.new(*, **); end
  def success?; end
  def to_h; end
  def update(hash); end
  extend Anonymous_Module_76
  include Anonymous_Dry_Core_Equalizer_74
  include Anonymous_Module_75
  include Dry::Core::Equalizer::Methods
  include Dry::Initializer::Mixin::Root
end
module Anonymous_Dry_Core_Equalizer_74
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Module_76
  extend Dry::Initializer::DSL
  include Dry::Initializer
end
module Anonymous_Module_75
  def __dry_initializer_config__; end
  def __dry_initializer_initialize__(output, *, **__dry_initializer_options__); end
  def message_compiler; end
  def result_ast; end
  extend Dry::Initializer::Mixin::Local
end
